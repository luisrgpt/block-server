I. Introduction
===============

Extract the lab.zip package into /tmp/sirs. All steps expect this to be done - you must change accordingly if you choose to move the files elsewhere.

In the directory "intro/inputs", you can find three different images:
- tecnico-*.png, the IST logo
- tux-*.png, Tux, the Linux penguin
- glider-*.png, the hacker emblem (http://www.catb.org/hacker-emblem/ )

Each one is present with three different dimensions: 480x480, 960x960, and 2400x2400.

You will begin with a visual introduction to the consequences of bad practices.

The ImageMixer class is available to facilitate the operations on images.
You will only have to worry about working with byte arrays.

Many examples are available, such as the RandomImageGenerator, ImageXor, and ImageAESCipher classes.


(for every java command, write "java pt.ulisboa.tecnico.meic.sirs.RandomImageGenerator" instead of "java RandomImageGenerator")

1. As you should know, one-time pads (OTPs), when correctly used, provide perfect security.
   One of the constraints to make them work as expected is that they must never be reused.

   You are about to visualize what happens when you reuse an OTP, even just once:

   a. Generate a new 480x480 random image into /tmp/sirs/intro/outputs/otp.png

      $ java RandomImageGenerator /tmp/sirs/intro/outputs/otp.png 480 480

   b. XOR tecnico-0480.png with the generated key

      $ java ImageXor /tmp/sirs/intro/inputs/tecnico-0480.png /tmp/sirs/intro/outputs/otp.png /tmp/sirs/intro/outputs/encrypted-tecnico.png

   c. XOR tux-0480.png with the same generated key

      $ java ImageXor /tmp/sirs/intro/inputs/tux-0480.png /tmp/sirs/intro/outputs/otp.png /tmp/sirs/intro/outputs/encrypted-tux.png

   d. Watch the images encrypted-tecnico.png and encrypted-tux.png. Switch between them, and see the differences.

   e. Make the differences obvious: XOR them together:

      $ java ImageXor /tmp/sirs/intro/outputs/encrypted-tecnico.png /tmp/sirs/intro/outputs/encrypted-tux.png /tmp/sirs/intro/outputs/tecnico-tux.png

   You can see that the reuse of a one-time pad (or any stream cipher key at all) considerably weakens (or completely breaks) the security of the information.
   Feel free to experiment with other images and other sizes.


2. Now that you know that keys should never be reused, remember that the way you use them is also important.

   You are about to use a symmetric-key encryption algorithm in modes ECB, CBC and OFB, to encrypt the pixels from an image.

-  2.1. Using the ECB (Electronic Code Book) mode:
        (Remember: in the ECB mode, each block m[i] is encrypted with key k independently: c[i] = Ek(m[i])

     a. Begin by generating a new AES Key

        $ java AESKeyGenerator w /tmp/sirs/intro/outputs/aes.key

     b. Then, encrypt the glider with it:

        $ java ImageAESCipher /tmp/sirs/intro/inputs/glider-0480.png /tmp/sirs/intro/outputs/aes.key ECB /tmp/sirs/intro/outputs/glider-aes-ecb.png

     c. Watch the output image. Remember what you've just done: encrypted the image with AES, using ECB mode, and a key you generated yourself.

     d. Feel free to try the same thing with the other images - especially with other sizes (2400x2400 are the most obvious).

     e. In case you believe the AES cipher is to blame for this, feel free to generate a DES key and use the DES classes provided.
        While the results will differ and appear less random, that will happen due to the fact that AES uses larger blocks than DES.
        The underlying problem of revealing the image pattern will still remain - you must not encrypt each block m[i] independently with the key k,
        or the function Ek(m[i]) will output the same ciphertext for similar plaintext blocks.

-  2.2. Using the CBC (Cipher Block Chaining) mode:
        (Remember: in the CBC mode, each block m[i] is XOR'd with the ciphertext from the previous block, and then encrypted with key k:
         c[i] = Ek(m[i] XOR c[i-1])
         Consider that c[-1] is a random, unique value, the Initialization Vector IV)

     a. The AES key will be the same from the previous step.

     b. Encrypt the glider with it, this time replacing ECB for CBC:

        $ java ImageAESCipher /tmp/sirs/intro/inputs/glider-0480.png /tmp/sirs/intro/outputs/aes.key CBC /tmp/sirs/intro/outputs/glider-aes-cbc.png

     c. Notice how different are the file sizes from glider-aes-ecb.png and glider-aes-cbc.png. Can you find a reason why?

     d. Watch the file glider-aes-cbc.png. See the difference it made, changing only the mode of operation.

-  2.2.1. Still on the CBC mode, you might have wondered why the IV is needed in the first block.
          Consider what happens when you encrypt two different images with similar beginnings, and with the same key k:
          the initial ciphertext blocks will also be similar!

          The ImageAESCipher class provided has been deliberately weakened: instead of randomizing the IV, it is always 0000000000000000.

     a. This time, encrypt the other two images with AES/CBC, still using the same AES key:

        $ java ImageAESCipher /tmp/sirs/intro/inputs/tux-0480.png /tmp/sirs/intro/outputs/aes.key CBC /tmp/sirs/intro/outputs/tux-aes-cbc.png
        $ java ImageAESCipher /tmp/sirs/intro/inputs/tecnico-0480.png /tmp/sirs/intro/outputs/aes.key CBC /tmp/sirs/intro/outputs/tecnico-aes-cbc.png

     b. Now watch the images glider-aes-cbc.png, tux-aes-cbc.png, and tecnico-aes-cbc.png
        Look to the first lines of pixels. Can you see what's going on?

-  2.3. Now, using the OFB (Output FeedBack) mode:
        (Remember: in the OFB mode, the IV is encrypted with the key to make a keystream, that is then XOR'ed with the plaintext to make the ciphertext)
        
        In practice, the OFB mode's keystream can be seen as the one-time pad that is used to encrypt a message.

        This automatically means that, in the OFB mode, if the key AND the IV are both reused, there is no security.
          
     a. Encrypt the images with OFB:

        $ java ImageAESCipher /tmp/sirs/intro/inputs/glider-0480.png /tmp/sirs/intro/outputs/aes.key OFB /tmp/sirs/intro/outputs/glider-aes-ofb.png
        $ java ImageAESCipher /tmp/sirs/intro/inputs/tux-0480.png /tmp/sirs/intro/outputs/aes.key OFB /tmp/sirs/intro/outputs/tux-aes-ofb.png
        $ java ImageAESCipher /tmp/sirs/intro/inputs/tecnico-0480.png /tmp/sirs/intro/outputs/aes.key OFB /tmp/sirs/intro/outputs/tecnico-aes-ofb.png

     b. Remember that the ImageAESCipher implementation has been weakened, by having a null IV, and you are reusing the same AES key.
        Watch the generated images, and switch quickly between them. You'll know what to do.
 
II. Tampering with a file
=========================

In the directory "grades/inputs", you can find the file grades.txt, the plaintext of a file with the grades of a class.

This flat-file database has a rigid structure: 64 bytes for name, and 16 bytes for each of the other fields, number, age and grade.

Unfortunately, you happen to be Mr. Thomas S. Cook, and your grade wasn't in par with the rest of your class.

1. Begin by encrypting this file into grades.ecb.aes, grades.cbc.aes and grades.ofb.aes. For this example, we'll still reuse the AES key generated above.

   $ java FileAESCipher /tmp/sirs/grades/inputs/grades.txt /tmp/sirs/intro/outputs/aes.key ECB /tmp/sirs/grades/outputs/grades.ecb.aes
   $ java FileAESCipher /tmp/sirs/grades/inputs/grades.txt /tmp/sirs/intro/outputs/aes.key CBC /tmp/sirs/grades/outputs/grades.cbc.aes
   $ java FileAESCipher /tmp/sirs/grades/inputs/grades.txt /tmp/sirs/intro/outputs/aes.key OFB /tmp/sirs/grades/outputs/grades.ofb.aes

2. Keeping in mind how the mode operations work, and without using the secret key, try to change your grade to 16 in all of the encrypted files.
   Did you succeed? Did your changes have side effects? If so, which ones, in which modes?
   Try to do this by yourself before reading the answer:

   - In the ECB mode, any change to a ciphertext block will completely randomize the corresponding plaintext block on decryption. This means that you can't determine how to change your grade deterministically.
     However, since each block is independent from the others, you can instead copy a whole block over the block you want to change. Since you know what the corresponding plaintext it, you are effectively changing the grade.
   - In the CBC mode, a change to a ciphertext block will randomize its plaintext, but will affect trivially the corresponding bits on the next block. 
     This means that you can change your grade deterministically, although it will also have the side-effect of garbling the previous block.
   - In the OFB mode, since the plaintext is XOR'd with the already encrypted keystream, any bit flip in the ciphertext will affect trivially the corresponding bit on the plaintext, with no side-effects.

   First, locate the changes you are planning to make. Imagine you want to apply a patch to the original plaintext:

   - Thomas Cook's grade is in line 4, column 97. Each line has 111 characters (and the newline character, making it 112)
   - (row,col)=(4,97) map to character 3*112 + 97-1 = 432. However, that is the first "1" in "11" - we only want to change the next character, which is 433.
   - In the ASCII table, '1' is 49, and '6' is 54.
   - Since you want to replace '1' with '6', with a XOR operation (because that's what will allow you to attack the ciphertext), you need to XOR '1' with something that will leave you with '6'.
     That something is '1' XOR '6' = 49 XOR 54 = 7.

   Let's attack the OFB implementation first. Open the AES/OFB encrypted file on a hexadecimal editor (like hexedit), and find the character in offset 433, or 0x1b1.
   If you don't have a hexeditor, you can use the FileXorByte class:

   $ cp /tmp/sirs/grades/outputs/grades.ofb.aes /tmp/sirs/grades/outputs/grades-tampered.ofb.aes
   $ java FileXorByte /tmp/sirs/grades/outputs/grades-tampered.ofb.aes 433 7

   It will XOR the character at position 433 with 7.

   Then, decrypt the file, and verify the change you made.

   $ java FileAESDecipher /tmp/sirs/grades/outputs/grades-tampered.ofb.aes /tmp/sirs/intro/outputs/aes.key OFB /tmp/sirs/grades/outputs/grades-tampered.ofb.aes.txt

   See how the change was undetectable.


   Now, let's attack the CBC implementation. While it is mostly similar to OFB, you have to subtract the block size to the offsets.
   Since AES works with 128-bit blocks. We need to apply the patch 16 bytes before the grade. That is, 433-16=417.

   $ cp /tmp/sirs/grades/outputs/grades.cbc.aes /tmp/sirs/grades/outputs/grades-tampered.cbc.aes
   $ java FileXorByte /tmp/sirs/grades/outputs/grades-tampered.cbc.aes 417 7

   $ java FileAESDecipher /tmp/sirs/grades/outputs/grades-tampered.cbc.aes /tmp/sirs/intro/outputs/aes.key CBC /tmp/sirs/grades/outputs/grades-tampered.cbc.aes.txt

   See how the grade was indeed changed to 16, but the previous block (with the age) is now garbled. While this situation may be fairly obvious to a human reader, it is possible that a computer program that receives this table may ignore this column.

   If you feel curious, take a look at the hexadecimal dumps aligned on 16 bytes for each file:

   $ xxd /tmp/sirs/grades/inputs/grades.txt
   $ xxd /tmp/sirs/grades/outputs/grades-tampered.ofb.aes.txt
   $ xxd /tmp/sirs/grades/outputs/grades-tampered.cbc.aes.txt

   You can see that exactly one 16 byte block was garbled in the CBC version, and everything else is intact - except, obviously, for the grade.


3. Since you're feeling generous, change Josh B. Stroud's grade to 16 too.


4. These files aren't very friendly to show up on screen. Create a Base64 representation of them:

   $ java Base64Encode /tmp/sirs/grades/outputs/grades.cbc.aes /tmp/sirs/grades/outputs/grades.cbc.aes.b64

   Decode them:

   $ java Base64Decode /tmp/sirs/grades/outputs/grades.cbc.aes.b64 /tmp/sirs/grades/outputs/grades.cbc.aes.b64.decoded

   Check if they are similar:

   $ diff /tmp/sirs/grades/outputs/grades.cbc.aes /tmp/sirs/grades/outputs/grades.cbc.aes.b64.decoded
   (it should not return anything)

   Check the difference on the file sizes. Can you explain it? In percent, how much is it?
   Does Base64 provide any kind of security? If so, how?





******************************************

Hash: the md5sum or sha256sum commands can be used to (re)calculate the hashes of the files

base64: The base64 command also does that easily.
The base64 files will always be larger than the files they encode, since the way base64 operates means that 8 bits are always required to represent blocks of 7 bits.
It is usually a difference of about 30-35%.

What happens when whitespace is added to the end of the files: the encrypted file will fail decryption, since there is invalid data in the end. base64 will also fail for the same reason, but in practice it will be able to decode the whole file until the first modification appears.

III


Generating a pair of keys with OpenSSL:

- Private key:
  $ openssl genrsa -out server.key 

- Public key:
  $ openssl rsa -in server.key -pubout

Generating a self-signed certificate with these keys:

- Certificate Signing Request, using same key:
  $ openssl req -new -key server.key -out server.csr
  (answer questions interactively)

- Self-sign:
  $ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt


- In order for our certificate to be able to sign other certificates, OpenSSL requires that a database exists (a .srl file). Create it:

  $ echo 01 > server.srl

- Then, generating a key to a user is basically repeating the same steps, except that the self-sign no longer happens and is replaced by:

  $ openssl x509 -req -days 365 -in user.csr -CA server.crt -CAkey server.key -out user.crt

- Sign the file grades.txt with the user certificate:

  $ openssl dgst -sha256 /tmp/sirs/grades/inputs/grades.txt > grades.sha256
  $ openssl rsautl -sign -inkey server.key -keyform PEM -in grades.sha256 > grades.sig

- Verify the signature:

  $ openssl rsautl -verify -in grades.sig -inkey server.key
  This output for me is:

  SHA256(/tmp/sirs/grades/inputs/grades.txt)= 770ddfe97cd0e6d279b9ce780ff060554d8ccbe4b8eccaed364a8fc6e89fd34d

  and should always match this:

  $ openssl dgst -sha256 /tmp/sirs/grades/inputs/grades.txt
  SHA256(/tmp/sirs/grades/inputs/grades.txt)= 770ddfe97cd0e6d279b9ce780ff060554d8ccbe4b8eccaed364a8fc6e89fd34d

- Verify the user certificate:

  $ openssl verify -CAfile server.crt user.crt
  
  user.crt: OK
